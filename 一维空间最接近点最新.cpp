#include<iostream>  #include<cstdlib>#include<ctime> using namespace std;struct Pair{	int d;//点对距离  	int d1, d2;//点对坐标  };Pair Cpair(int a[], int l, int r);int Partition(int s[],int l, int r);int Min(int  s[], int l, int r);int Max(int s[], int l, int r);int GetMid(int a[], int l, int r);int main() {	srand((unsigned)time(NULL));	int n;	int *a;	cout << "Please enter array length:\n";	cin >> n;	a = new int[n];	for (int i = 0; i < n; i++){		a[i] = rand() % 50;	}	cout << "The elements of the array are:\n";	for (int j = 0; j < n; j++){		cout << a[j] << "\t";	}	cout << endl;	Pair de = Cpair(a, 0, n - 1);	cout << "Minimum point pair:" << endl;	cout << de.d1 << " " << de.d2 << endl;	cout << "The distance of the smallest pair of points:" << de.d << endl;	cout << "Sorted point:" << endl;	for (int h = 0; h < n; h++){		cout << a[h] << "\t";	}	cout << endl;	return 0;}//返回s[]中的最小值int Min(int  s[], int l, int r){	int  s_min = s[l];	for (int i = l + 1; i <= r; i++)		if (s_min > s[i])			s_min = s[i];	return s_min;}//返回s[]中的最大值int Max(int s[], int l, int r){	int  s_max = s[l];	for (int i = l + 1; i <= r; i++)		if (s_max < s[i])			s_max = s[i];	return s_max;}int Partition(int a[],int l, int r){	int i, num = l;	for (i = l + 1; i <= r; i++) {		if (a[i] < a[l]) {			swap(a[i], a[++num]);		}	}	swap(a[l], a[num]);	return num;}int GetMid(int a[], int l, int r) {	int mid = (l + r) / 2;	while (1) {		int pos = Partition(a, l, r);		if (pos == mid) break;		else if (pos > mid) r = pos - 1;		else l = pos + 1;	}	cout << "median = " << a[mid] << endl;	return mid;	}Pair Cpair(int a[], int l, int r){	Pair min_d = { 99999,0,0 };	if (r - l < 1)   // 递归结束项，r.l指向同一个点，返回到主函数		return min_d;	int k = GetMid(a, l, r);  //计算中位数 	//s1为: l到k  s2为k+1到r	Pair d1 = Cpair(a, l, k); 	Pair d2 = Cpair(a, k + 1, r);	int p = Max(a, l, k), q = Min(a, k + 1, r);	int k1 = q - p;	//以下内容都是: d=min(d1,d2,q-p)（找出最接近点对）	if (d1.d < d2.d){ //递归结束，返回上一层递归		if (k1 < d1.d){			min_d.d = k1;			min_d.d1 = q;			min_d.d2 = p;			return min_d; 		}		else return d1;	}	else {		if (k1 < d2.d){			min_d.d = k1;			min_d.d1 = q;			min_d.d2 = p;			return min_d;		}		else return d2;	}}